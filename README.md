# Домашнее задание по функциональному программированию

## Задание 1

### Подзадание 1

#### Условие

Написать функцию cat n, вычисляющую n-ое число Каталана по рекуррентной формуле (формулу можно выбрать любую, но должно считаться C_50 например без проблем).

#### Решение

Для решения я использую формулу с [Википедии](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0):

![zero catalan number](https://wikimedia.org/api/rest_v1/media/math/render/svg/483e5f622e83e24c5a54dd6a54c4ab50f8845dc6)

![nth catalan number](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f687dd98b3370030522012c5fe9e5834e2b8b7)

### Позадание 2

#### Условие

Написать функцию, соединяющую конечное (n) количество списков, которые могут быть бесконечными так, чтобы для любого n и любого k нашлось m такое, чтобы для списка ls вызов take m ls вывел результат, в котором было бы хотя бы по k элементов из каждого списка. Иными словами, объединить списки так, чтобы можно было просматривать каждый из списков в объединённом.

#### Решение

Будем брать первый элемент каждого списка и последовательно добавлять в список-ответ, после чего, будем удалять этот элемент из исходного списка и повторять операцию, пока не опустошим все списки. При этом не забываем после каждой итерации чистить пустые списки.

## Задание 2

#### Условие

Рассмотрим граф, задаваемый следующим образом (списками смежности):
```type Graph = [(Int, [Int])]``` . Вершины пронумерованы от ```1``` до ```n```. В каждом кортеже в списке выше указан номер вершины и список номеров вершин, у которых с ней общее ребро.

а) Проверить, корректно ли заданное описание графа (имеется в виду, что граф неориентированный)

б) Проверить, состоит ли граф (корректно заданный) из одной компоненты связности

#### Решение

а) Для каждой вершины графа ```A``` для каждого его ребра, ведущего в вершину ```B``` попытаемся найти парное ребро из ```B``` в ```A```. Если у каждого ребра есть пара - граф задан верно, иначе неверно.

б) Запустим ```bfs``` из вершины ```1``` и посчитаем количество вершин, которые мы посетим. Если количество посещенных вершин равно количесту вершин графа, то компонента связности одна.

## Задание 3

### Условие

Получить бесконечный список знаков после запятой числа е. П.С. это никак не связано с аппроксимацией, примерными вычислениями, точностями и тому подобным. Результатом выполнения программы должен быть бесконечный список в хаскелевской терминологии!

### Решение

Воспользуемся рядом Тейлора для экспоненты

![teilor_exp](https://wikimedia.org/api/rest_v1/media/math/render/svg/f9d608a7a5651b1c89a517dbdbfa12b868ad7d92)

В нашем случае ```x = 1```.

Создадим бесконечный список, в котором будем хранить сумму ряда до ```i```-ого элемента. Обращаясь к элементам этого списка, можно получить ```i```-ую цифру после запятой числа ```e```. Для того, чтобы избежать погрешность, так как сумма ряда, например, для ```2``` элементов не сможет соответствовать ```2```-ой цифре после запятой. Начнем считать ряд с какой-то начальной суммы. Я выбрал сумму до ```10```-ого элемента.

Итого, для вычисления ```i + 1```-ой цифры числа ```e``` будет вычисляться сумма ряда для ```i + 11```-ого элемента и из нее будет браться необходимая цифра.
