# Домашнее задание по функциональному программированию

## Задание 1

### Подзадание 1

#### Условие

Написать функцию cat n, вычисляющую n-ое число Каталана по рекуррентной формуле (формулу можно выбрать любую, но должно считаться C_50 например без проблем).

#### Решение

Для решения я использую формулу с [Википедии](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0):

![zero catalan number](https://wikimedia.org/api/rest_v1/media/math/render/svg/483e5f622e83e24c5a54dd6a54c4ab50f8845dc6)

![nth catalan number](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f687dd98b3370030522012c5fe9e5834e2b8b7)

### Позадание 2

#### Условие

Написать функцию, соединяющую конечное (n) количество списков, которые могут быть бесконечными так, чтобы для любого n и любого k нашлось m такое, чтобы для списка ls вызов take m ls вывел результат, в котором было бы хотя бы по k элементов из каждого списка. Иными словами, объединить списки так, чтобы можно было просматривать каждый из списков в объединённом.

#### Решение

Будем брать первый элемент каждого списка и последовательно добавлять в список-ответ, после чего, будем удалять этот элемент из исходного списка и повторять операцию, пока не опустошим все списки. При этом не забываем после каждой итерации чистить пустые списки.

## Задание 2

#### Условие

Рассмотрим граф, задаваемый следующим образом (списками смежности):
```type Graph = [(Int, [Int])]``` . Вершины пронумерованы от ```1``` до ```n```. В каждом кортеже в списке выше указан номер вершины и список номеров вершин, у которых с ней общее ребро.

а) Проверить, корректно ли заданное описание графа (имеется в виду, что граф неориентированный)

б) Проверить, состоит ли граф (корректно заданный) из одной компоненты связности

#### Решение

а) Для каждой вершины графа ```A``` для каждого его ребра, ведущего в вершину ```B``` попытаемся найти парное ребро из ```B``` в ```A```. Если у каждого ребра есть пара - граф задан верно, иначе неверно.

б) Запустим ```bfs``` из вершины ```1``` и посчитаем количество вершин, которые мы посетим. Если количество посещенных вершин равно количесту вершин графа, то компонента связности одна.
